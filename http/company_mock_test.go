package http

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i ugc_test_task/http.CompanyManager -o ./company_manager_test.go -n CompanyManagerMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"
	"ugc_test_task/companymng"
	"ugc_test_task/models"

	"github.com/gojuno/minimock/v3"
)

// CompanyManagerMock implements CompanyManager
type CompanyManagerMock struct {
	t minimock.Tester

	funcAddCompany          func(query companymng.AddQuery) (c1 models.Company, err error)
	inspectFuncAddCompany   func(query companymng.AddQuery)
	afterAddCompanyCounter  uint64
	beforeAddCompanyCounter uint64
	AddCompanyMock          mCompanyManagerMockAddCompany

	funcGetCompanies          func(query companymng.GetQuery, clb func(firm models.Company) error) (err error)
	inspectFuncGetCompanies   func(query companymng.GetQuery, clb func(firm models.Company) error)
	afterGetCompaniesCounter  uint64
	beforeGetCompaniesCounter uint64
	GetCompaniesMock          mCompanyManagerMockGetCompanies
}

// NewCompanyManagerMock returns a mock for CompanyManager
func NewCompanyManagerMock(t minimock.Tester) *CompanyManagerMock {
	m := &CompanyManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCompanyMock = mCompanyManagerMockAddCompany{mock: m}
	m.AddCompanyMock.callArgs = []*CompanyManagerMockAddCompanyParams{}

	m.GetCompaniesMock = mCompanyManagerMockGetCompanies{mock: m}
	m.GetCompaniesMock.callArgs = []*CompanyManagerMockGetCompaniesParams{}

	return m
}

type mCompanyManagerMockAddCompany struct {
	mock               *CompanyManagerMock
	defaultExpectation *CompanyManagerMockAddCompanyExpectation
	expectations       []*CompanyManagerMockAddCompanyExpectation

	callArgs []*CompanyManagerMockAddCompanyParams
	mutex    sync.RWMutex
}

// CompanyManagerMockAddCompanyExpectation specifies expectation struct of the CompanyManager.AddCompany
type CompanyManagerMockAddCompanyExpectation struct {
	mock    *CompanyManagerMock
	params  *CompanyManagerMockAddCompanyParams
	results *CompanyManagerMockAddCompanyResults
	Counter uint64
}

// CompanyManagerMockAddCompanyParams contains parameters of the CompanyManager.AddCompany
type CompanyManagerMockAddCompanyParams struct {
	query companymng.AddQuery
}

// CompanyManagerMockAddCompanyResults contains results of the CompanyManager.AddCompany
type CompanyManagerMockAddCompanyResults struct {
	c1  models.Company
	err error
}

// Expect sets up expected params for CompanyManager.AddCompany
func (mmAddCompany *mCompanyManagerMockAddCompany) Expect(query companymng.AddQuery) *mCompanyManagerMockAddCompany {
	if mmAddCompany.mock.funcAddCompany != nil {
		mmAddCompany.mock.t.Fatalf("CompanyManagerMock.AddCompany mock is already set by Set")
	}

	if mmAddCompany.defaultExpectation == nil {
		mmAddCompany.defaultExpectation = &CompanyManagerMockAddCompanyExpectation{}
	}

	mmAddCompany.defaultExpectation.params = &CompanyManagerMockAddCompanyParams{query}
	for _, e := range mmAddCompany.expectations {
		if minimock.Equal(e.params, mmAddCompany.defaultExpectation.params) {
			mmAddCompany.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCompany.defaultExpectation.params)
		}
	}

	return mmAddCompany
}

// Inspect accepts an inspector function that has same arguments as the CompanyManager.AddCompany
func (mmAddCompany *mCompanyManagerMockAddCompany) Inspect(f func(query companymng.AddQuery)) *mCompanyManagerMockAddCompany {
	if mmAddCompany.mock.inspectFuncAddCompany != nil {
		mmAddCompany.mock.t.Fatalf("Inspect function is already set for CompanyManagerMock.AddCompany")
	}

	mmAddCompany.mock.inspectFuncAddCompany = f

	return mmAddCompany
}

// Return sets up results that will be returned by CompanyManager.AddCompany
func (mmAddCompany *mCompanyManagerMockAddCompany) Return(c1 models.Company, err error) *CompanyManagerMock {
	if mmAddCompany.mock.funcAddCompany != nil {
		mmAddCompany.mock.t.Fatalf("CompanyManagerMock.AddCompany mock is already set by Set")
	}

	if mmAddCompany.defaultExpectation == nil {
		mmAddCompany.defaultExpectation = &CompanyManagerMockAddCompanyExpectation{mock: mmAddCompany.mock}
	}
	mmAddCompany.defaultExpectation.results = &CompanyManagerMockAddCompanyResults{c1, err}
	return mmAddCompany.mock
}

//Set uses given function f to mock the CompanyManager.AddCompany method
func (mmAddCompany *mCompanyManagerMockAddCompany) Set(f func(query companymng.AddQuery) (c1 models.Company, err error)) *CompanyManagerMock {
	if mmAddCompany.defaultExpectation != nil {
		mmAddCompany.mock.t.Fatalf("Default expectation is already set for the CompanyManager.AddCompany method")
	}

	if len(mmAddCompany.expectations) > 0 {
		mmAddCompany.mock.t.Fatalf("Some expectations are already set for the CompanyManager.AddCompany method")
	}

	mmAddCompany.mock.funcAddCompany = f
	return mmAddCompany.mock
}

// When sets expectation for the CompanyManager.AddCompany which will trigger the result defined by the following
// Then helper
func (mmAddCompany *mCompanyManagerMockAddCompany) When(query companymng.AddQuery) *CompanyManagerMockAddCompanyExpectation {
	if mmAddCompany.mock.funcAddCompany != nil {
		mmAddCompany.mock.t.Fatalf("CompanyManagerMock.AddCompany mock is already set by Set")
	}

	expectation := &CompanyManagerMockAddCompanyExpectation{
		mock:   mmAddCompany.mock,
		params: &CompanyManagerMockAddCompanyParams{query},
	}
	mmAddCompany.expectations = append(mmAddCompany.expectations, expectation)
	return expectation
}

// Then sets up CompanyManager.AddCompany return parameters for the expectation previously defined by the When method
func (e *CompanyManagerMockAddCompanyExpectation) Then(c1 models.Company, err error) *CompanyManagerMock {
	e.results = &CompanyManagerMockAddCompanyResults{c1, err}
	return e.mock
}

// AddCompany implements CompanyManager
func (mmAddCompany *CompanyManagerMock) AddCompany(query companymng.AddQuery) (c1 models.Company, err error) {
	mm_atomic.AddUint64(&mmAddCompany.beforeAddCompanyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCompany.afterAddCompanyCounter, 1)

	if mmAddCompany.inspectFuncAddCompany != nil {
		mmAddCompany.inspectFuncAddCompany(query)
	}

	mm_params := &CompanyManagerMockAddCompanyParams{query}

	// Record call args
	mmAddCompany.AddCompanyMock.mutex.Lock()
	mmAddCompany.AddCompanyMock.callArgs = append(mmAddCompany.AddCompanyMock.callArgs, mm_params)
	mmAddCompany.AddCompanyMock.mutex.Unlock()

	for _, e := range mmAddCompany.AddCompanyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmAddCompany.AddCompanyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCompany.AddCompanyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCompany.AddCompanyMock.defaultExpectation.params
		mm_got := CompanyManagerMockAddCompanyParams{query}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCompany.t.Errorf("CompanyManagerMock.AddCompany got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCompany.AddCompanyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCompany.t.Fatal("No results are set for the CompanyManagerMock.AddCompany")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmAddCompany.funcAddCompany != nil {
		return mmAddCompany.funcAddCompany(query)
	}
	mmAddCompany.t.Fatalf("Unexpected call to CompanyManagerMock.AddCompany. %v", query)
	return
}

// AddCompanyAfterCounter returns a count of finished CompanyManagerMock.AddCompany invocations
func (mmAddCompany *CompanyManagerMock) AddCompanyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCompany.afterAddCompanyCounter)
}

// AddCompanyBeforeCounter returns a count of CompanyManagerMock.AddCompany invocations
func (mmAddCompany *CompanyManagerMock) AddCompanyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCompany.beforeAddCompanyCounter)
}

// Calls returns a list of arguments used in each call to CompanyManagerMock.AddCompany.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCompany *mCompanyManagerMockAddCompany) Calls() []*CompanyManagerMockAddCompanyParams {
	mmAddCompany.mutex.RLock()

	argCopy := make([]*CompanyManagerMockAddCompanyParams, len(mmAddCompany.callArgs))
	copy(argCopy, mmAddCompany.callArgs)

	mmAddCompany.mutex.RUnlock()

	return argCopy
}

// MinimockAddCompanyDone returns true if the count of the AddCompany invocations corresponds
// the number of defined expectations
func (m *CompanyManagerMock) MinimockAddCompanyDone() bool {
	for _, e := range m.AddCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCompanyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCompany != nil && mm_atomic.LoadUint64(&m.afterAddCompanyCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddCompanyInspect logs each unmet expectation
func (m *CompanyManagerMock) MinimockAddCompanyInspect() {
	for _, e := range m.AddCompanyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CompanyManagerMock.AddCompany with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCompanyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCompanyCounter) < 1 {
		if m.AddCompanyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CompanyManagerMock.AddCompany")
		} else {
			m.t.Errorf("Expected call to CompanyManagerMock.AddCompany with params: %#v", *m.AddCompanyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCompany != nil && mm_atomic.LoadUint64(&m.afterAddCompanyCounter) < 1 {
		m.t.Error("Expected call to CompanyManagerMock.AddCompany")
	}
}

type mCompanyManagerMockGetCompanies struct {
	mock               *CompanyManagerMock
	defaultExpectation *CompanyManagerMockGetCompaniesExpectation
	expectations       []*CompanyManagerMockGetCompaniesExpectation

	callArgs []*CompanyManagerMockGetCompaniesParams
	mutex    sync.RWMutex
}

// CompanyManagerMockGetCompaniesExpectation specifies expectation struct of the CompanyManager.GetCompanies
type CompanyManagerMockGetCompaniesExpectation struct {
	mock    *CompanyManagerMock
	params  *CompanyManagerMockGetCompaniesParams
	results *CompanyManagerMockGetCompaniesResults
	Counter uint64
}

// CompanyManagerMockGetCompaniesParams contains parameters of the CompanyManager.GetCompanies
type CompanyManagerMockGetCompaniesParams struct {
	query companymng.GetQuery
	clb   func(firm models.Company) error
}

// CompanyManagerMockGetCompaniesResults contains results of the CompanyManager.GetCompanies
type CompanyManagerMockGetCompaniesResults struct {
	err error
}

// Expect sets up expected params for CompanyManager.GetCompanies
func (mmGetCompanies *mCompanyManagerMockGetCompanies) Expect(query companymng.GetQuery, clb func(firm models.Company) error) *mCompanyManagerMockGetCompanies {
	if mmGetCompanies.mock.funcGetCompanies != nil {
		mmGetCompanies.mock.t.Fatalf("CompanyManagerMock.GetCompanies mock is already set by Set")
	}

	if mmGetCompanies.defaultExpectation == nil {
		mmGetCompanies.defaultExpectation = &CompanyManagerMockGetCompaniesExpectation{}
	}

	mmGetCompanies.defaultExpectation.params = &CompanyManagerMockGetCompaniesParams{query, clb}
	for _, e := range mmGetCompanies.expectations {
		if minimock.Equal(e.params, mmGetCompanies.defaultExpectation.params) {
			mmGetCompanies.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCompanies.defaultExpectation.params)
		}
	}

	return mmGetCompanies
}

// Inspect accepts an inspector function that has same arguments as the CompanyManager.GetCompanies
func (mmGetCompanies *mCompanyManagerMockGetCompanies) Inspect(f func(query companymng.GetQuery, clb func(firm models.Company) error)) *mCompanyManagerMockGetCompanies {
	if mmGetCompanies.mock.inspectFuncGetCompanies != nil {
		mmGetCompanies.mock.t.Fatalf("Inspect function is already set for CompanyManagerMock.GetCompanies")
	}

	mmGetCompanies.mock.inspectFuncGetCompanies = f

	return mmGetCompanies
}

// Return sets up results that will be returned by CompanyManager.GetCompanies
func (mmGetCompanies *mCompanyManagerMockGetCompanies) Return(err error) *CompanyManagerMock {
	if mmGetCompanies.mock.funcGetCompanies != nil {
		mmGetCompanies.mock.t.Fatalf("CompanyManagerMock.GetCompanies mock is already set by Set")
	}

	if mmGetCompanies.defaultExpectation == nil {
		mmGetCompanies.defaultExpectation = &CompanyManagerMockGetCompaniesExpectation{mock: mmGetCompanies.mock}
	}
	mmGetCompanies.defaultExpectation.results = &CompanyManagerMockGetCompaniesResults{err}
	return mmGetCompanies.mock
}

//Set uses given function f to mock the CompanyManager.GetCompanies method
func (mmGetCompanies *mCompanyManagerMockGetCompanies) Set(f func(query companymng.GetQuery, clb func(firm models.Company) error) (err error)) *CompanyManagerMock {
	if mmGetCompanies.defaultExpectation != nil {
		mmGetCompanies.mock.t.Fatalf("Default expectation is already set for the CompanyManager.GetCompanies method")
	}

	if len(mmGetCompanies.expectations) > 0 {
		mmGetCompanies.mock.t.Fatalf("Some expectations are already set for the CompanyManager.GetCompanies method")
	}

	mmGetCompanies.mock.funcGetCompanies = f
	return mmGetCompanies.mock
}

// When sets expectation for the CompanyManager.GetCompanies which will trigger the result defined by the following
// Then helper
func (mmGetCompanies *mCompanyManagerMockGetCompanies) When(query companymng.GetQuery, clb func(firm models.Company) error) *CompanyManagerMockGetCompaniesExpectation {
	if mmGetCompanies.mock.funcGetCompanies != nil {
		mmGetCompanies.mock.t.Fatalf("CompanyManagerMock.GetCompanies mock is already set by Set")
	}

	expectation := &CompanyManagerMockGetCompaniesExpectation{
		mock:   mmGetCompanies.mock,
		params: &CompanyManagerMockGetCompaniesParams{query, clb},
	}
	mmGetCompanies.expectations = append(mmGetCompanies.expectations, expectation)
	return expectation
}

// Then sets up CompanyManager.GetCompanies return parameters for the expectation previously defined by the When method
func (e *CompanyManagerMockGetCompaniesExpectation) Then(err error) *CompanyManagerMock {
	e.results = &CompanyManagerMockGetCompaniesResults{err}
	return e.mock
}

// GetCompanies implements CompanyManager
func (mmGetCompanies *CompanyManagerMock) GetCompanies(query companymng.GetQuery, clb func(firm models.Company) error) (err error) {
	mm_atomic.AddUint64(&mmGetCompanies.beforeGetCompaniesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCompanies.afterGetCompaniesCounter, 1)

	if mmGetCompanies.inspectFuncGetCompanies != nil {
		mmGetCompanies.inspectFuncGetCompanies(query, clb)
	}

	mm_params := &CompanyManagerMockGetCompaniesParams{query, clb}

	// Record call args
	mmGetCompanies.GetCompaniesMock.mutex.Lock()
	mmGetCompanies.GetCompaniesMock.callArgs = append(mmGetCompanies.GetCompaniesMock.callArgs, mm_params)
	mmGetCompanies.GetCompaniesMock.mutex.Unlock()

	for _, e := range mmGetCompanies.GetCompaniesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGetCompanies.GetCompaniesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCompanies.GetCompaniesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCompanies.GetCompaniesMock.defaultExpectation.params
		mm_got := CompanyManagerMockGetCompaniesParams{query, clb}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCompanies.t.Errorf("CompanyManagerMock.GetCompanies got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCompanies.GetCompaniesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCompanies.t.Fatal("No results are set for the CompanyManagerMock.GetCompanies")
		}
		return (*mm_results).err
	}
	if mmGetCompanies.funcGetCompanies != nil {
		return mmGetCompanies.funcGetCompanies(query, clb)
	}
	mmGetCompanies.t.Fatalf("Unexpected call to CompanyManagerMock.GetCompanies. %v %v", query, clb)
	return
}

// GetCompaniesAfterCounter returns a count of finished CompanyManagerMock.GetCompanies invocations
func (mmGetCompanies *CompanyManagerMock) GetCompaniesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCompanies.afterGetCompaniesCounter)
}

// GetCompaniesBeforeCounter returns a count of CompanyManagerMock.GetCompanies invocations
func (mmGetCompanies *CompanyManagerMock) GetCompaniesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCompanies.beforeGetCompaniesCounter)
}

// Calls returns a list of arguments used in each call to CompanyManagerMock.GetCompanies.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCompanies *mCompanyManagerMockGetCompanies) Calls() []*CompanyManagerMockGetCompaniesParams {
	mmGetCompanies.mutex.RLock()

	argCopy := make([]*CompanyManagerMockGetCompaniesParams, len(mmGetCompanies.callArgs))
	copy(argCopy, mmGetCompanies.callArgs)

	mmGetCompanies.mutex.RUnlock()

	return argCopy
}

// MinimockGetCompaniesDone returns true if the count of the GetCompanies invocations corresponds
// the number of defined expectations
func (m *CompanyManagerMock) MinimockGetCompaniesDone() bool {
	for _, e := range m.GetCompaniesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCompaniesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCompaniesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCompanies != nil && mm_atomic.LoadUint64(&m.afterGetCompaniesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCompaniesInspect logs each unmet expectation
func (m *CompanyManagerMock) MinimockGetCompaniesInspect() {
	for _, e := range m.GetCompaniesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CompanyManagerMock.GetCompanies with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCompaniesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCompaniesCounter) < 1 {
		if m.GetCompaniesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CompanyManagerMock.GetCompanies")
		} else {
			m.t.Errorf("Expected call to CompanyManagerMock.GetCompanies with params: %#v", *m.GetCompaniesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCompanies != nil && mm_atomic.LoadUint64(&m.afterGetCompaniesCounter) < 1 {
		m.t.Error("Expected call to CompanyManagerMock.GetCompanies")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CompanyManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddCompanyInspect()

		m.MinimockGetCompaniesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CompanyManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CompanyManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCompanyDone() &&
		m.MinimockGetCompaniesDone()
}
