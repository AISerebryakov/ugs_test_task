package http

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i ugc_test_task/http.BuildingManager -o ./building_manager_test.go -n BuildingManagerMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"
	buildmng "ugc_test_task/managers/buildings"
	"ugc_test_task/models"

	"github.com/gojuno/minimock/v3"
)

// BuildingManagerMock implements BuildingManager
type BuildingManagerMock struct {
	t minimock.Tester

	funcAddBuilding          func(query buildmng.AddQuery) (b1 models.Building, err error)
	inspectFuncAddBuilding   func(query buildmng.AddQuery)
	afterAddBuildingCounter  uint64
	beforeAddBuildingCounter uint64
	AddBuildingMock          mBuildingManagerMockAddBuilding

	funcGetBuildings          func(query buildmng.GetQuery, callback func(models.Building) error) (err error)
	inspectFuncGetBuildings   func(query buildmng.GetQuery, callback func(models.Building) error)
	afterGetBuildingsCounter  uint64
	beforeGetBuildingsCounter uint64
	GetBuildingsMock          mBuildingManagerMockGetBuildings
}

// NewBuildingManagerMock returns a mock for BuildingManager
func NewBuildingManagerMock(t minimock.Tester) *BuildingManagerMock {
	m := &BuildingManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddBuildingMock = mBuildingManagerMockAddBuilding{mock: m}
	m.AddBuildingMock.callArgs = []*BuildingManagerMockAddBuildingParams{}

	m.GetBuildingsMock = mBuildingManagerMockGetBuildings{mock: m}
	m.GetBuildingsMock.callArgs = []*BuildingManagerMockGetBuildingsParams{}

	return m
}

type mBuildingManagerMockAddBuilding struct {
	mock               *BuildingManagerMock
	defaultExpectation *BuildingManagerMockAddBuildingExpectation
	expectations       []*BuildingManagerMockAddBuildingExpectation

	callArgs []*BuildingManagerMockAddBuildingParams
	mutex    sync.RWMutex
}

// BuildingManagerMockAddBuildingExpectation specifies expectation struct of the BuildingManager.AddBuilding
type BuildingManagerMockAddBuildingExpectation struct {
	mock    *BuildingManagerMock
	params  *BuildingManagerMockAddBuildingParams
	results *BuildingManagerMockAddBuildingResults
	Counter uint64
}

// BuildingManagerMockAddBuildingParams contains parameters of the BuildingManager.AddBuilding
type BuildingManagerMockAddBuildingParams struct {
	query buildmng.AddQuery
}

// BuildingManagerMockAddBuildingResults contains results of the BuildingManager.AddBuilding
type BuildingManagerMockAddBuildingResults struct {
	b1  models.Building
	err error
}

// Expect sets up expected params for BuildingManager.AddBuilding
func (mmAddBuilding *mBuildingManagerMockAddBuilding) Expect(query buildmng.AddQuery) *mBuildingManagerMockAddBuilding {
	if mmAddBuilding.mock.funcAddBuilding != nil {
		mmAddBuilding.mock.t.Fatalf("BuildingManagerMock.AddBuilding mock is already set by Set")
	}

	if mmAddBuilding.defaultExpectation == nil {
		mmAddBuilding.defaultExpectation = &BuildingManagerMockAddBuildingExpectation{}
	}

	mmAddBuilding.defaultExpectation.params = &BuildingManagerMockAddBuildingParams{query}
	for _, e := range mmAddBuilding.expectations {
		if minimock.Equal(e.params, mmAddBuilding.defaultExpectation.params) {
			mmAddBuilding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddBuilding.defaultExpectation.params)
		}
	}

	return mmAddBuilding
}

// Inspect accepts an inspector function that has same arguments as the BuildingManager.AddBuilding
func (mmAddBuilding *mBuildingManagerMockAddBuilding) Inspect(f func(query buildmng.AddQuery)) *mBuildingManagerMockAddBuilding {
	if mmAddBuilding.mock.inspectFuncAddBuilding != nil {
		mmAddBuilding.mock.t.Fatalf("Inspect function is already set for BuildingManagerMock.AddBuilding")
	}

	mmAddBuilding.mock.inspectFuncAddBuilding = f

	return mmAddBuilding
}

// Return sets up results that will be returned by BuildingManager.AddBuilding
func (mmAddBuilding *mBuildingManagerMockAddBuilding) Return(b1 models.Building, err error) *BuildingManagerMock {
	if mmAddBuilding.mock.funcAddBuilding != nil {
		mmAddBuilding.mock.t.Fatalf("BuildingManagerMock.AddBuilding mock is already set by Set")
	}

	if mmAddBuilding.defaultExpectation == nil {
		mmAddBuilding.defaultExpectation = &BuildingManagerMockAddBuildingExpectation{mock: mmAddBuilding.mock}
	}
	mmAddBuilding.defaultExpectation.results = &BuildingManagerMockAddBuildingResults{b1, err}
	return mmAddBuilding.mock
}

//Set uses given function f to mock the BuildingManager.AddBuilding method
func (mmAddBuilding *mBuildingManagerMockAddBuilding) Set(f func(query buildmng.AddQuery) (b1 models.Building, err error)) *BuildingManagerMock {
	if mmAddBuilding.defaultExpectation != nil {
		mmAddBuilding.mock.t.Fatalf("Default expectation is already set for the BuildingManager.AddBuilding method")
	}

	if len(mmAddBuilding.expectations) > 0 {
		mmAddBuilding.mock.t.Fatalf("Some expectations are already set for the BuildingManager.AddBuilding method")
	}

	mmAddBuilding.mock.funcAddBuilding = f
	return mmAddBuilding.mock
}

// When sets expectation for the BuildingManager.AddBuilding which will trigger the result defined by the following
// Then helper
func (mmAddBuilding *mBuildingManagerMockAddBuilding) When(query buildmng.AddQuery) *BuildingManagerMockAddBuildingExpectation {
	if mmAddBuilding.mock.funcAddBuilding != nil {
		mmAddBuilding.mock.t.Fatalf("BuildingManagerMock.AddBuilding mock is already set by Set")
	}

	expectation := &BuildingManagerMockAddBuildingExpectation{
		mock:   mmAddBuilding.mock,
		params: &BuildingManagerMockAddBuildingParams{query},
	}
	mmAddBuilding.expectations = append(mmAddBuilding.expectations, expectation)
	return expectation
}

// Then sets up BuildingManager.AddBuilding return parameters for the expectation previously defined by the When method
func (e *BuildingManagerMockAddBuildingExpectation) Then(b1 models.Building, err error) *BuildingManagerMock {
	e.results = &BuildingManagerMockAddBuildingResults{b1, err}
	return e.mock
}

// AddBuilding implements BuildingManager
func (mmAddBuilding *BuildingManagerMock) AddBuilding(query buildmng.AddQuery) (b1 models.Building, err error) {
	mm_atomic.AddUint64(&mmAddBuilding.beforeAddBuildingCounter, 1)
	defer mm_atomic.AddUint64(&mmAddBuilding.afterAddBuildingCounter, 1)

	if mmAddBuilding.inspectFuncAddBuilding != nil {
		mmAddBuilding.inspectFuncAddBuilding(query)
	}

	mm_params := &BuildingManagerMockAddBuildingParams{query}

	// Record call args
	mmAddBuilding.AddBuildingMock.mutex.Lock()
	mmAddBuilding.AddBuildingMock.callArgs = append(mmAddBuilding.AddBuildingMock.callArgs, mm_params)
	mmAddBuilding.AddBuildingMock.mutex.Unlock()

	for _, e := range mmAddBuilding.AddBuildingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmAddBuilding.AddBuildingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddBuilding.AddBuildingMock.defaultExpectation.Counter, 1)
		mm_want := mmAddBuilding.AddBuildingMock.defaultExpectation.params
		mm_got := BuildingManagerMockAddBuildingParams{query}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddBuilding.t.Errorf("BuildingManagerMock.AddBuilding got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddBuilding.AddBuildingMock.defaultExpectation.results
		if mm_results == nil {
			mmAddBuilding.t.Fatal("No results are set for the BuildingManagerMock.AddBuilding")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmAddBuilding.funcAddBuilding != nil {
		return mmAddBuilding.funcAddBuilding(query)
	}
	mmAddBuilding.t.Fatalf("Unexpected call to BuildingManagerMock.AddBuilding. %v", query)
	return
}

// AddBuildingAfterCounter returns a count of finished BuildingManagerMock.AddBuilding invocations
func (mmAddBuilding *BuildingManagerMock) AddBuildingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBuilding.afterAddBuildingCounter)
}

// AddBuildingBeforeCounter returns a count of BuildingManagerMock.AddBuilding invocations
func (mmAddBuilding *BuildingManagerMock) AddBuildingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddBuilding.beforeAddBuildingCounter)
}

// Calls returns a list of arguments used in each call to BuildingManagerMock.AddBuilding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddBuilding *mBuildingManagerMockAddBuilding) Calls() []*BuildingManagerMockAddBuildingParams {
	mmAddBuilding.mutex.RLock()

	argCopy := make([]*BuildingManagerMockAddBuildingParams, len(mmAddBuilding.callArgs))
	copy(argCopy, mmAddBuilding.callArgs)

	mmAddBuilding.mutex.RUnlock()

	return argCopy
}

// MinimockAddBuildingDone returns true if the count of the AddBuilding invocations corresponds
// the number of defined expectations
func (m *BuildingManagerMock) MinimockAddBuildingDone() bool {
	for _, e := range m.AddBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddBuildingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddBuildingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBuilding != nil && mm_atomic.LoadUint64(&m.afterAddBuildingCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddBuildingInspect logs each unmet expectation
func (m *BuildingManagerMock) MinimockAddBuildingInspect() {
	for _, e := range m.AddBuildingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingManagerMock.AddBuilding with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddBuildingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddBuildingCounter) < 1 {
		if m.AddBuildingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingManagerMock.AddBuilding")
		} else {
			m.t.Errorf("Expected call to BuildingManagerMock.AddBuilding with params: %#v", *m.AddBuildingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddBuilding != nil && mm_atomic.LoadUint64(&m.afterAddBuildingCounter) < 1 {
		m.t.Error("Expected call to BuildingManagerMock.AddBuilding")
	}
}

type mBuildingManagerMockGetBuildings struct {
	mock               *BuildingManagerMock
	defaultExpectation *BuildingManagerMockGetBuildingsExpectation
	expectations       []*BuildingManagerMockGetBuildingsExpectation

	callArgs []*BuildingManagerMockGetBuildingsParams
	mutex    sync.RWMutex
}

// BuildingManagerMockGetBuildingsExpectation specifies expectation struct of the BuildingManager.GetBuildings
type BuildingManagerMockGetBuildingsExpectation struct {
	mock    *BuildingManagerMock
	params  *BuildingManagerMockGetBuildingsParams
	results *BuildingManagerMockGetBuildingsResults
	Counter uint64
}

// BuildingManagerMockGetBuildingsParams contains parameters of the BuildingManager.GetBuildings
type BuildingManagerMockGetBuildingsParams struct {
	query    buildmng.GetQuery
	callback func(models.Building) error
}

// BuildingManagerMockGetBuildingsResults contains results of the BuildingManager.GetBuildings
type BuildingManagerMockGetBuildingsResults struct {
	err error
}

// Expect sets up expected params for BuildingManager.GetBuildings
func (mmGetBuildings *mBuildingManagerMockGetBuildings) Expect(query buildmng.GetQuery, callback func(models.Building) error) *mBuildingManagerMockGetBuildings {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingManagerMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingManagerMockGetBuildingsExpectation{}
	}

	mmGetBuildings.defaultExpectation.params = &BuildingManagerMockGetBuildingsParams{query, callback}
	for _, e := range mmGetBuildings.expectations {
		if minimock.Equal(e.params, mmGetBuildings.defaultExpectation.params) {
			mmGetBuildings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBuildings.defaultExpectation.params)
		}
	}

	return mmGetBuildings
}

// Inspect accepts an inspector function that has same arguments as the BuildingManager.GetBuildings
func (mmGetBuildings *mBuildingManagerMockGetBuildings) Inspect(f func(query buildmng.GetQuery, callback func(models.Building) error)) *mBuildingManagerMockGetBuildings {
	if mmGetBuildings.mock.inspectFuncGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("Inspect function is already set for BuildingManagerMock.GetBuildings")
	}

	mmGetBuildings.mock.inspectFuncGetBuildings = f

	return mmGetBuildings
}

// Return sets up results that will be returned by BuildingManager.GetBuildings
func (mmGetBuildings *mBuildingManagerMockGetBuildings) Return(err error) *BuildingManagerMock {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingManagerMock.GetBuildings mock is already set by Set")
	}

	if mmGetBuildings.defaultExpectation == nil {
		mmGetBuildings.defaultExpectation = &BuildingManagerMockGetBuildingsExpectation{mock: mmGetBuildings.mock}
	}
	mmGetBuildings.defaultExpectation.results = &BuildingManagerMockGetBuildingsResults{err}
	return mmGetBuildings.mock
}

//Set uses given function f to mock the BuildingManager.GetBuildings method
func (mmGetBuildings *mBuildingManagerMockGetBuildings) Set(f func(query buildmng.GetQuery, callback func(models.Building) error) (err error)) *BuildingManagerMock {
	if mmGetBuildings.defaultExpectation != nil {
		mmGetBuildings.mock.t.Fatalf("Default expectation is already set for the BuildingManager.GetBuildings method")
	}

	if len(mmGetBuildings.expectations) > 0 {
		mmGetBuildings.mock.t.Fatalf("Some expectations are already set for the BuildingManager.GetBuildings method")
	}

	mmGetBuildings.mock.funcGetBuildings = f
	return mmGetBuildings.mock
}

// When sets expectation for the BuildingManager.GetBuildings which will trigger the result defined by the following
// Then helper
func (mmGetBuildings *mBuildingManagerMockGetBuildings) When(query buildmng.GetQuery, callback func(models.Building) error) *BuildingManagerMockGetBuildingsExpectation {
	if mmGetBuildings.mock.funcGetBuildings != nil {
		mmGetBuildings.mock.t.Fatalf("BuildingManagerMock.GetBuildings mock is already set by Set")
	}

	expectation := &BuildingManagerMockGetBuildingsExpectation{
		mock:   mmGetBuildings.mock,
		params: &BuildingManagerMockGetBuildingsParams{query, callback},
	}
	mmGetBuildings.expectations = append(mmGetBuildings.expectations, expectation)
	return expectation
}

// Then sets up BuildingManager.GetBuildings return parameters for the expectation previously defined by the When method
func (e *BuildingManagerMockGetBuildingsExpectation) Then(err error) *BuildingManagerMock {
	e.results = &BuildingManagerMockGetBuildingsResults{err}
	return e.mock
}

// GetBuildings implements BuildingManager
func (mmGetBuildings *BuildingManagerMock) GetBuildings(query buildmng.GetQuery, callback func(models.Building) error) (err error) {
	mm_atomic.AddUint64(&mmGetBuildings.beforeGetBuildingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBuildings.afterGetBuildingsCounter, 1)

	if mmGetBuildings.inspectFuncGetBuildings != nil {
		mmGetBuildings.inspectFuncGetBuildings(query, callback)
	}

	mm_params := &BuildingManagerMockGetBuildingsParams{query, callback}

	// Record call args
	mmGetBuildings.GetBuildingsMock.mutex.Lock()
	mmGetBuildings.GetBuildingsMock.callArgs = append(mmGetBuildings.GetBuildingsMock.callArgs, mm_params)
	mmGetBuildings.GetBuildingsMock.mutex.Unlock()

	for _, e := range mmGetBuildings.GetBuildingsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGetBuildings.GetBuildingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBuildings.GetBuildingsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBuildings.GetBuildingsMock.defaultExpectation.params
		mm_got := BuildingManagerMockGetBuildingsParams{query, callback}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBuildings.t.Errorf("BuildingManagerMock.GetBuildings got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBuildings.GetBuildingsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBuildings.t.Fatal("No results are set for the BuildingManagerMock.GetBuildings")
		}
		return (*mm_results).err
	}
	if mmGetBuildings.funcGetBuildings != nil {
		return mmGetBuildings.funcGetBuildings(query, callback)
	}
	mmGetBuildings.t.Fatalf("Unexpected call to BuildingManagerMock.GetBuildings. %v %v", query, callback)
	return
}

// GetBuildingsAfterCounter returns a count of finished BuildingManagerMock.GetBuildings invocations
func (mmGetBuildings *BuildingManagerMock) GetBuildingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuildings.afterGetBuildingsCounter)
}

// GetBuildingsBeforeCounter returns a count of BuildingManagerMock.GetBuildings invocations
func (mmGetBuildings *BuildingManagerMock) GetBuildingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBuildings.beforeGetBuildingsCounter)
}

// Calls returns a list of arguments used in each call to BuildingManagerMock.GetBuildings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBuildings *mBuildingManagerMockGetBuildings) Calls() []*BuildingManagerMockGetBuildingsParams {
	mmGetBuildings.mutex.RLock()

	argCopy := make([]*BuildingManagerMockGetBuildingsParams, len(mmGetBuildings.callArgs))
	copy(argCopy, mmGetBuildings.callArgs)

	mmGetBuildings.mutex.RUnlock()

	return argCopy
}

// MinimockGetBuildingsDone returns true if the count of the GetBuildings invocations corresponds
// the number of defined expectations
func (m *BuildingManagerMock) MinimockGetBuildingsDone() bool {
	for _, e := range m.GetBuildingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBuildingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBuildingsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBuildings != nil && mm_atomic.LoadUint64(&m.afterGetBuildingsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBuildingsInspect logs each unmet expectation
func (m *BuildingManagerMock) MinimockGetBuildingsInspect() {
	for _, e := range m.GetBuildingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BuildingManagerMock.GetBuildings with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBuildingsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBuildingsCounter) < 1 {
		if m.GetBuildingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BuildingManagerMock.GetBuildings")
		} else {
			m.t.Errorf("Expected call to BuildingManagerMock.GetBuildings with params: %#v", *m.GetBuildingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBuildings != nil && mm_atomic.LoadUint64(&m.afterGetBuildingsCounter) < 1 {
		m.t.Error("Expected call to BuildingManagerMock.GetBuildings")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BuildingManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddBuildingInspect()

		m.MinimockGetBuildingsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BuildingManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BuildingManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddBuildingDone() &&
		m.MinimockGetBuildingsDone()
}
